// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use super::super::{Value, Variable, Operator, Statement, Expression};
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "string" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "\"");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_string_inquotes(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "\"");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Value::Str(s)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "string" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "string" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_string_inquotes<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "string_inquotes" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            '\"' =>
                                            state.mark_failure(pos, "[^\"]"),
                                            _ => Matched(next, ()),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[^\"]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str.to_string() })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "string_inquotes" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "string_inquotes" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_int<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<i32> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "int" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        match slice_eq(input, state, pos, "-") {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => { Matched(pos, None) }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                if input.len() > pos {
                                                    let (ch, next) =
                                                        char_range_at(input,
                                                                      pos);
                                                    match ch {
                                                        '0' ...'9' =>
                                                        Matched(next, ()),
                                                        _ =>
                                                        state.mark_failure(pos,
                                                                           "[0-9]"),
                                                    }
                                                } else {
                                                    state.mark_failure(pos,
                                                                       "[0-9]")
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1usize {
                                            Matched(repeat_pos, ())
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        match_str.parse::<i32>().unwrap()
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "int" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "int" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_float<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<f32> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "float" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            '0' ...'9' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[0-9]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[0-9]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ".");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    let mut repeat_value =
                                                        vec!();
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            if input.len() >
                                                                   pos {
                                                                let (ch,
                                                                     next) =
                                                                    char_range_at(input,
                                                                                  pos);
                                                                match ch {
                                                                    '0' ...'9'
                                                                    =>
                                                                    Matched(next,
                                                                            ()),
                                                                    _ =>
                                                                    state.mark_failure(pos,
                                                                                       "[0-9]"),
                                                                }
                                                            } else {
                                                                state.mark_failure(pos,
                                                                                   "[0-9]")
                                                            };
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                                repeat_value.push(value);
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    if repeat_value.len() >=
                                                           1usize {
                                                        Matched(repeat_pos,
                                                                ())
                                                    } else { Failed }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    match_str.parse::<f32>().unwrap()
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "float"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "float" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_v_int<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "v_int" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_int(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Value::Int(i) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "v_int"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "v_int" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_v_float<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "v_float" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_float(input, state, pos);
                    match seq_res {
                        Matched(pos, f) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Value::Float(f) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "v_float" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "v_float" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_truth<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "truth" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "rick");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Value::Bool(true) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "truth"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "truth" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_falsehood<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "falsehood" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "morty");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Value::Bool(false) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "falsehood" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "falsehood" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_boolean<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "boolean" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_truth(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => parse_falsehood(input, state, pos),
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "boolean" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "boolean" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_instantiation<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_instantiation" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "on a cob");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Statement::ListNew(i)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_instantiation" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_instantiation" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_append<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_append" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "assimilate");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_whitespace(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Statement::ListAppend(i,
                                                                                                                  e)
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_append" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_append" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_statements<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_statements" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_list_instantiation(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_list_append(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_list_assign(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_list_deletion(input, state, pos),
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_statements" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_statements" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_index<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_index" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_optional_whitespace(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "[");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_optional_whitespace(input,
                                                                                      state,
                                                                                      pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_optional_whitespace(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         "]");
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let match_str =
                                                                                                            &input[start_pos..pos];
                                                                                                        Matched(pos,
                                                                                                                {
                                                                                                                    Expression::ListIndex(i,
                                                                                                                                          Box::new(e))
                                                                                                                })
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_index" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_index" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_value<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Value> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "value" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_v_float(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_v_int(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_string(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_boolean(input, state, pos),
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "value"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "value" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_identifier<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "identifier" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        if input.len() > pos {
                            let (ch, next) = char_range_at(input, pos);
                            match ch {
                                'a' ...'z' | 'A' ...'Z' => Matched(next, ()),
                                _ => state.mark_failure(pos, "[a-zA-Z]"),
                            }
                        } else { state.mark_failure(pos, "[a-zA-Z]") };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                if input.len() > pos {
                                                    let (ch, next) =
                                                        char_range_at(input,
                                                                      pos);
                                                    match ch {
                                                        'a' ...'z' | 'A'
                                                        ...'Z' | '0' ...'9' |
                                                        '_' =>
                                                        Matched(next, ()),
                                                        _ =>
                                                        state.mark_failure(pos,
                                                                           "[a-zA-Z0-9_]"),
                                                    }
                                                } else {
                                                    state.mark_failure(pos,
                                                                       "[a-zA-Z0-9_]")
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        Matched(repeat_pos, ())
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    { match_str.to_string() })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "identifier" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "identifier" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_plus<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "plus" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "+");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Add })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "plus"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "plus" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_minus<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "minus" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "-");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Subtract })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "minus"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "minus" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_times<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "times" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "*");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Multiply })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "times"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "times" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_divide<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "divide" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "/");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Divide })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "divide" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "divide" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_equality<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "equality" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "==");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Equality })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "equality" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "equality" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_gt<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "gt" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "more");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::GreaterThan })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "gt" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "gt" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_lt<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "lt" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "less");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::LessThan })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "lt" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "lt" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_gte<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "gte" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "moresquanch");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::GreaterThanEqual })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "gte" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "gte" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_lte<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "lte" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "lesssquanch");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::LessThanEqual })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "lte" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "lte" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_shl<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "shl" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "<schwift");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::ShiftLeft })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "shl" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "shl" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_shr<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "shr" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "schwift>");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::ShiftRight })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "shr" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "shr" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_or<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "or" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "or");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::Or })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "or" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "or" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_and<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "and" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "and");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Operator::And })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "and" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "and" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_operator<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Operator> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "operator" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_plus(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_minus(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_times(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_divide(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_equality(input,
                                                                   state,
                                                                   pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            parse_gte(input,
                                                                      state,
                                                                      pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_lte(input,
                                                                              state,
                                                                              pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    {
                                                                        let choice_res =
                                                                            parse_gt(input,
                                                                                     state,
                                                                                     pos);
                                                                        match choice_res
                                                                            {
                                                                            Matched(pos,
                                                                                    value)
                                                                            =>
                                                                            Matched(pos,
                                                                                    value),
                                                                            Failed
                                                                            =>
                                                                            {
                                                                                let choice_res =
                                                                                    parse_lt(input,
                                                                                             state,
                                                                                             pos);
                                                                                match choice_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            value)
                                                                                    =>
                                                                                    Matched(pos,
                                                                                            value),
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        let choice_res =
                                                                                            parse_shr(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                        match choice_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    value)
                                                                                            =>
                                                                                            Matched(pos,
                                                                                                    value),
                                                                                            Failed
                                                                                            =>
                                                                                            {
                                                                                                let choice_res =
                                                                                                    parse_shl(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                                match choice_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            value)
                                                                                                    =>
                                                                                                    Matched(pos,
                                                                                                            value),
                                                                                                    Failed
                                                                                                    =>
                                                                                                    {
                                                                                                        let choice_res =
                                                                                                            parse_or(input,
                                                                                                                     state,
                                                                                                                     pos);
                                                                                                        match choice_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    value)
                                                                                                            =>
                                                                                                            Matched(pos,
                                                                                                                    value),
                                                                                                            Failed
                                                                                                            =>
                                                                                                            parse_and(input,
                                                                                                                      state,
                                                                                                                      pos),
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "operator" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "operator" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_whitespace<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "whitespace" , line , col , pos);
        let mut __peg_closure = || {
            {
                let mut repeat_pos = pos;
                let mut repeat_value = vec!();
                loop  {
                    let pos = repeat_pos;
                    let step_res =
                        if input.len() > pos {
                            let (ch, next) = char_range_at(input, pos);
                            match ch {
                                ' ' | '\t' => Matched(next, ()),
                                _ => state.mark_failure(pos, "[ \t]"),
                            }
                        } else { state.mark_failure(pos, "[ \t]") };
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => { break ; }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, ())
                } else { Failed }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "whitespace" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "whitespace" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_if_statement<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "if_statement" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_if_else(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => parse_bare_if(input, state, pos),
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "if_statement" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "if_statement" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_bare_if<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "bare_if" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "if");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_expression(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let seq_res =
                                                            parse_whitespace(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_block(input,
                                                                                    state,
                                                                                    pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                s)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Statement::If(e,
                                                                                                          s,
                                                                                                          Option::None)
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "bare_if" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "bare_if" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_if_else<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "if_else" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "if");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_expression(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let seq_res =
                                                            parse_whitespace(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_block(input,
                                                                                    state,
                                                                                    pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                i_bod)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_optional_whitespace(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         "else");
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_whitespace(input,
                                                                                                                             state,
                                                                                                                             pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        parse_block(input,
                                                                                                                                    state,
                                                                                                                                    pos);
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                e_bod)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    &input[start_pos..pos];
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            Statement::If(e,
                                                                                                                                                          i_bod,
                                                                                                                                                          Option::Some(e_bod))
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "if_else" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "if_else" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_while_loop<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "while_loop" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "while");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_expression(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let seq_res =
                                                            parse_whitespace(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_block(input,
                                                                                    state,
                                                                                    pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                b)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Statement::While(e,
                                                                                                             b)
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "while_loop" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "while_loop" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_block<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Vec<Statement>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "block" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, ":<");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_optional_whitespace(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            parse_newline(input,
                                                                          state,
                                                                          pos);
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    Matched(repeat_pos, ())
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let mut repeat_pos =
                                                                    pos;
                                                                let mut repeat_value =
                                                                    vec!();
                                                                loop  {
                                                                    let pos =
                                                                        repeat_pos;
                                                                    let step_res =
                                                                        parse_line(input,
                                                                                   state,
                                                                                   pos);
                                                                    match step_res
                                                                        {
                                                                        Matched(newpos,
                                                                                value)
                                                                        => {
                                                                            repeat_pos
                                                                                =
                                                                                newpos;
                                                                            repeat_value.push(value);
                                                                        }
                                                                        Failed
                                                                        => {
                                                                            break
                                                                                ;
                                                                        }
                                                                    }
                                                                }
                                                                Matched(repeat_pos,
                                                                        repeat_value)
                                                            };
                                                        match seq_res {
                                                            Matched(pos, l) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_optional_whitespace(input,
                                                                                                  state,
                                                                                                  pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             ">:");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                &input[start_pos..pos];
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        l
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "block"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "block" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_statement_ws<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "statement_ws" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        parse_optional_whitespace(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_statement(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                parse_optional_whitespace(input,
                                                                          state,
                                                                          pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { s })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "statement_ws" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "statement_ws" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_statements_ws<'input>(input: &'input str,
                               state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<Statement>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "statements_ws" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let pos =
                                    if repeat_value.len() > 0 {
                                        let sep_res =
                                            parse_newline(input, state, pos);
                                        match sep_res {
                                            Matched(newpos, _) => { newpos }
                                            Failed => break ,
                                        }
                                    } else { pos };
                                let step_res =
                                    parse_statement_ws(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, s) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { s })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "statements_ws" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "statements_ws" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_assignment<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "assignment" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "squanch");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_whitespace(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Statement::Assignment(i,
                                                                                                                  e)
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "assignment" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "assignment" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_deletion<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "deletion" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "squanch");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_identifier(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Statement::Delete(i)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "deletion" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "deletion" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_deletion<'input>(input: &'input str,
                               state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_deletion" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "squanch");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_identifier(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let seq_res =
                                                            parse_optional_whitespace(input,
                                                                                      state,
                                                                                      pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        slice_eq(input,
                                                                                 state,
                                                                                 pos,
                                                                                 "[");
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_optional_whitespace(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse_expression(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        e)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_optional_whitespace(input,
                                                                                                                                      state,
                                                                                                                                      pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        slice_eq(input,
                                                                                                                                 state,
                                                                                                                                 pos,
                                                                                                                                 "]");
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    &input[start_pos..pos];
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            Statement::ListDelete(i,
                                                                                                                                                                  e)
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_deletion" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_deletion" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_line<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "line" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        parse_optional_whitespace(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_statement(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                parse_optional_whitespace(input,
                                                                          state,
                                                                          pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let mut repeat_pos =
                                                                    pos;
                                                                loop  {
                                                                    let pos =
                                                                        repeat_pos;
                                                                    let step_res =
                                                                        parse_newline(input,
                                                                                      state,
                                                                                      pos);
                                                                    match step_res
                                                                        {
                                                                        Matched(newpos,
                                                                                value)
                                                                        => {
                                                                            repeat_pos
                                                                                =
                                                                                newpos;
                                                                        }
                                                                        Failed
                                                                        => {
                                                                            break
                                                                                ;
                                                                        }
                                                                    }
                                                                }
                                                                Matched(repeat_pos,
                                                                        ())
                                                            };
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                s
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "line"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "line" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_input<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "input" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "portal gun");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_identifier(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Statement::Input(i)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "input"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "input" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_file<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Vec<Statement>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "file" , line , col , pos);
        let mut __peg_closure = || {
            {
                let mut repeat_pos = pos;
                let mut repeat_value = vec!();
                loop  {
                    let pos = repeat_pos;
                    let step_res = parse_line(input, state, pos);
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => { break ; }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, repeat_value)
                } else { Failed }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "file"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "file" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_optional_whitespace<'input>(input: &'input str,
                                     state: &mut ParseState<'input>,
                                     pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "optional_whitespace" , line , col , pos);
        let mut __peg_closure = || {
            {
                let mut repeat_pos = pos;
                loop  {
                    let pos = repeat_pos;
                    let step_res =
                        if input.len() > pos {
                            let (ch, next) = char_range_at(input, pos);
                            match ch {
                                ' ' | '\t' => Matched(next, ()),
                                _ => state.mark_failure(pos, "[ \t]"),
                            }
                        } else { state.mark_failure(pos, "[ \t]") };
                    match step_res {
                        Matched(newpos, value) => { repeat_pos = newpos; }
                        Failed => { break ; }
                    }
                }
                Matched(repeat_pos, ())
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "optional_whitespace" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "optional_whitespace" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_newline<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "newline" , line , col , pos);
        let mut __peg_closure = || { slice_eq(input, state, pos, "\n") };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "newline" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "newline" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_statement<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "statement" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_list_statements(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_deletion(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_assignment(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_printing(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_if_statement(input,
                                                                       state,
                                                                       pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            parse_while_loop(input,
                                                                             state,
                                                                             pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_input(input,
                                                                        state,
                                                                        pos),
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "statement" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "statement" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_assign<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_assign" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_optional_whitespace(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "[");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_optional_whitespace(input,
                                                                                      state,
                                                                                      pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                v)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_optional_whitespace(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         "]");
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_whitespace(input,
                                                                                                                             state,
                                                                                                                             pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        slice_eq(input,
                                                                                                                                 state,
                                                                                                                                 pos,
                                                                                                                                 "squanch");
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let seq_res =
                                                                                                                                    parse_whitespace(input,
                                                                                                                                                     state,
                                                                                                                                                     pos);
                                                                                                                                match seq_res
                                                                                                                                    {
                                                                                                                                    Matched(pos,
                                                                                                                                            _)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        {
                                                                                                                                            let seq_res =
                                                                                                                                                parse_expression(input,
                                                                                                                                                                 state,
                                                                                                                                                                 pos);
                                                                                                                                            match seq_res
                                                                                                                                                {
                                                                                                                                                Matched(pos,
                                                                                                                                                        e)
                                                                                                                                                =>
                                                                                                                                                {
                                                                                                                                                    {
                                                                                                                                                        let match_str =
                                                                                                                                                            &input[start_pos..pos];
                                                                                                                                                        Matched(pos,
                                                                                                                                                                {
                                                                                                                                                                    Statement::ListAssign(i,
                                                                                                                                                                                          v,
                                                                                                                                                                                          e)
                                                                                                                                                                })
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                Failed
                                                                                                                                                =>
                                                                                                                                                Failed,
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    Failed
                                                                                                                                    =>
                                                                                                                                    Failed,
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_assign" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_assign" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_printing<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Statement> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "printing" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        slice_eq(input, state, pos, "show me what you got");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_expression(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Statement::Print(e)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "printing" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "printing" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_expression<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "expression" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_not(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_operator_expression(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_list_index(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_value_expression(input,
                                                                   state,
                                                                   pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_list_length(input,
                                                                      state,
                                                                      pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_variable_expression(input,
                                                                              state,
                                                                              pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "expression" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "expression" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_list_length<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "list_length" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res =
                                    parse_whitespace(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "squanch");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Expression::ListLength(i)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "list_length" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "list_length" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_not<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "not" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "!");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_optional_whitespace(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_expression(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Expression::Not(Box::new(e))
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "not" ,
                     line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "not" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_expression1<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "expression1" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_list_index(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_value_expression(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_list_length(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_variable_expression(input,
                                                                      state,
                                                                      pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_not(input, state, pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "expression1" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "expression1" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_operator_expression<'input>(input: &'input str,
                                     state: &mut ParseState<'input>,
                                     pos: usize) -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "operator_expression" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_expression1(input, state, pos);
                    match seq_res {
                        Matched(pos, e1) => {
                            {
                                let seq_res =
                                    parse_optional_whitespace(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_operator(input, state,
                                                               pos);
                                            match seq_res {
                                                Matched(pos, o) => {
                                                    {
                                                        let seq_res =
                                                            parse_optional_whitespace(input,
                                                                                      state,
                                                                                      pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e2)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Expression::OperatorExpression(Box::new(e1),
                                                                                                                           o,
                                                                                                                           Box::new(e2))
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "operator_expression" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "operator_expression" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_value_expression<'input>(input: &'input str,
                                  state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "value_expression" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_value(input, state, pos);
                    match seq_res {
                        Matched(pos, v) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Expression::Value(v) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "value_expression" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "value_expression" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_variable_expression<'input>(input: &'input str,
                                     state: &mut ParseState<'input>,
                                     pos: usize) -> RuleResult<Expression> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "variable_expression" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Expression::Variable(i) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "variable_expression" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "variable_expression" , line , col , pos),
        }
        __peg_result
    }
}
pub fn string<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_string(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn string_inquotes<'input>(input: &'input str) -> ParseResult<String> {
    let mut state = ParseState::new();
    match parse_string_inquotes(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn int<'input>(input: &'input str) -> ParseResult<i32> {
    let mut state = ParseState::new();
    match parse_int(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn float<'input>(input: &'input str) -> ParseResult<f32> {
    let mut state = ParseState::new();
    match parse_float(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn v_int<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_v_int(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn v_float<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_v_float(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn truth<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_truth(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn falsehood<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_falsehood(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn boolean<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_boolean(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_instantiation<'input>(input: &'input str)
 -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_list_instantiation(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_append<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_list_append(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_statements<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_list_statements(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_index<'input>(input: &'input str) -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_list_index(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn value<'input>(input: &'input str) -> ParseResult<Value> {
    let mut state = ParseState::new();
    match parse_value(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn identifier<'input>(input: &'input str) -> ParseResult<String> {
    let mut state = ParseState::new();
    match parse_identifier(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn plus<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_plus(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn minus<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_minus(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn times<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_times(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn divide<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_divide(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn equality<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_equality(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn gt<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_gt(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn lt<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_lt(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn gte<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_gte(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn lte<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_lte(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn shl<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_shl(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn shr<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_shr(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn operator<'input>(input: &'input str) -> ParseResult<Operator> {
    let mut state = ParseState::new();
    match parse_operator(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn whitespace<'input>(input: &'input str) -> ParseResult<()> {
    let mut state = ParseState::new();
    match parse_whitespace(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn if_statement<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_if_statement(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn bare_if<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_bare_if(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn if_else<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_if_else(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn while_loop<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_while_loop(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn block<'input>(input: &'input str) -> ParseResult<Vec<Statement>> {
    let mut state = ParseState::new();
    match parse_block(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn statement_ws<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_statement_ws(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn statements_ws<'input>(input: &'input str)
 -> ParseResult<Vec<Statement>> {
    let mut state = ParseState::new();
    match parse_statements_ws(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn assignment<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_assignment(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn deletion<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_deletion(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_deletion<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_list_deletion(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn line<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_line(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn input<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_input(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn file<'input>(input: &'input str) -> ParseResult<Vec<Statement>> {
    let mut state = ParseState::new();
    match parse_file(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn optional_whitespace<'input>(input: &'input str) -> ParseResult<()> {
    let mut state = ParseState::new();
    match parse_optional_whitespace(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn newline<'input>(input: &'input str) -> ParseResult<()> {
    let mut state = ParseState::new();
    match parse_newline(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn statement<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_statement(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_assign<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_list_assign(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn printing<'input>(input: &'input str) -> ParseResult<Statement> {
    let mut state = ParseState::new();
    match parse_printing(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn expression<'input>(input: &'input str) -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_expression(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn list_length<'input>(input: &'input str) -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_list_length(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn not<'input>(input: &'input str) -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_not(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn expression1<'input>(input: &'input str) -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_expression1(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn operator_expression<'input>(input: &'input str)
 -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_operator_expression(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn value_expression<'input>(input: &'input str)
 -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_value_expression(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn variable_expression<'input>(input: &'input str)
 -> ParseResult<Expression> {
    let mut state = ParseState::new();
    match parse_variable_expression(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
